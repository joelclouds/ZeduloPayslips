from src.config_manager import ConfigManager
from datetime import datetime
from src.services.tax_calc import ghana_tax_calculator
from src.services.db import YTD_Tracker
from openpyxl import load_workbook
from pathlib import Path
import shutil
import subprocess
from decimal import Decimal

class Column_header:
    def __init__(self, **kwargs):
        self.employee_sheet = kwargs.get("spreadsheet", None)
        self.header         = kwargs.get("header", "").strip()
        self.column         = None
        self.column_index   = None
        self.search_header()

    def search_header(self):
        headers        = [cell.value.strip() for cell in self.employee_sheet[1]]
        header_columns = [cell.column for cell in self.employee_sheet[1]]

        if (self.header and
            self.header in headers):
            chosen_index = headers.index(self.header)
            self.column  = header_columns[chosen_index]
            self.column_index = self.column -1
        else:
            self.column = None
            self.column_index = None
            return -1

def first_date_of_month(month_num):
    year = datetime.now().year
    return year, month_num, 1

def last_date_of_month(month_num):
    year = datetime.now().year
    assert month_num in range(1, 13)

    if month_num in [9, 4, 6, 11]:
        day = 30
    elif month_num == 2:
        leap_year = not year % 4
        day = 29 if leap_year else 28
    else:
        day = 31

    return year, month_num, day

class PayslipGenerator:
    def __init__(self, month_no, **kwargs):
        """
        Loads Employee spreadsheet.
        Sets general payslip info.
        Finds important Columm Headers based on config values.
        Iterates over every non-empty row of "employee data".
        Fills payslip template file.
        """
        self.settings = ConfigManager().load()
        self.progress_callback = kwargs.get("progress_callback", None)
        self.counter = 0
        self.total   = 0

        # Load Employee Spreadsheet
        self.employee_sheet_filepath = self.settings["EMPLOYEE_SPREADSHEET_FILEPATH"]
        self.month_no       = month_no
        self.month          = datetime(1970, month_no, 1).strftime("%B")
        self.employee_sheet = None
        self.employee_sheet_headers = None
        self.template_sheet_cells   = None
        self.start_datetime_str = datetime(*first_date_of_month(month_no)).strftime("%d/%m/%Y")
        self.end_datetime_str   = datetime(*last_date_of_month(month_no)).strftime("%d/%m/%Y")

        self.load_employee_sheet()
        self._init_employee_sheet_headers()
        self._init_template_sheet_cells()

    def _init_employee_sheet_headers(self):
        # Find (important) Column Headers
        self.employee_sheet_headers = {
            "name"          : Column_header(spreadsheet=self.employee_sheet, header=self.settings["EMPLOYEE_NAME_HEADER"]),
            "staff_number"  : Column_header(spreadsheet=self.employee_sheet, header=self.settings["EMPLOYEE_STAFF_NUMBER_HEADER"]),
            "email"         : Column_header(spreadsheet=self.employee_sheet, header=self.settings["EMPLOYEE_EMAIL_HEADER"]),
            "tin"           : Column_header(spreadsheet=self.employee_sheet, header=self.settings["EMPLOYEE_TIN_HEADER"]),
            "position"      : Column_header(spreadsheet=self.employee_sheet, header=self.settings["EMPLOYEE_POSITION_HEADER"]),
            "department"    : Column_header(spreadsheet=self.employee_sheet, header=self.settings["EMPLOYEE_DEPARTMENT_HEADER"]),
            "account_number": Column_header(spreadsheet=self.employee_sheet, header=self.settings["EMPLOYEE_ACCOUNT_NUMBER_HEADER"]),
            "gross_income"  : Column_header(spreadsheet=self.employee_sheet, header=self.settings["EMPLOYEE_GROSS_INCOME_HEADER"]),
            "untaxed_bonus" : Column_header(spreadsheet=self.employee_sheet, header=self.settings["EMPLOYEE_UNTAXED_BONUS_HEADER"])
        }

    def _init_template_sheet_cells(self):
        self.template_sheet_cells = {
            "payslip_date": {
                "location": self.settings["TEMPLATE_PAYSLIP_DATE_CELL"],
                "value"   : f"Date: {datetime.now().strftime('%d/%m/%Y')}"
             },
            "payslip_period" : {
                "location": self.settings["TEMPLATE_PAYSLIP_PERIOD_CELL"],
                "value"   : f"{self.start_datetime_str} - {self.end_datetime_str}"
            },
            "payslip_number" : {
                "location": self.settings["TEMPLATE_PAYSLIP_NUMBER_CELL"],
                "value"   : f"ZED{self.month_no}"
            },
            "name" : {
                "location": self.settings["TEMPLATE_NAME_CELL"],
                "value"   : None
            },
            "staff_number" : {
                "location": self.settings["TEMPLATE_STAFF_NUMBER_CELL"],
                "value"   : None
            },
            "email" : {
                "location": self.settings["TEMPLATE_EMAIL_CELL"],
                "value"   : None
            },
            "tin" : {
                "location": self.settings["TEMPLATE_TIN_CELL"],
                "value"   : None
            },
            "position" : {
                "location": self.settings["TEMPLATE_POSITION_CELL"],
                "value"   : None
            },
            "department" : {
                "location": self.settings["TEMPLATE_DEPARTMENT_CELL"],
                "value"   : None
            },
            "account_number": {
                "location": self.settings["TEMPLATE_ACCOUNT_NUMBER_CELL"],
                "value"   : None
            },
            "gross_income"  : {
                "location": self.settings["TEMPLATE_GROSS_INCOME_CELL"],
                "value"   : None
            },
            "untaxed_bonus" : {
                "location": self.settings["TEMPLATE_UNTAXED_BONUS_CELL"],
                "value"   : None
            },

            "employee_ssf" : {
                "location": self.settings["TEMPLATE_EMPLOYEE_SSF_CELL"],
                "value"   : None
            },
            "income_tax"   : {
                "location": self.settings["TEMPLATE_INCOME_TAX_CELL"],
                "value"   : None
            },
            "tier_2"       : {
                "location": self.settings["TEMPLATE_TIER_2_CELL"],
                "value"   : None
            },
            "employer_ssf" : {
                "location": self.settings["TEMPLATE_EMPLOYER_SSF_CELL"],
                "value"   : None
            },
            "bonus_tax"    : {
                "location": self.settings["TEMPLATE_BONUS_TAX_CELL"],
                "value"   : None
            },
            "total_deductions" : {
                "location": self.settings["TEMPLATE_TOTAL_DEDUCTIONS_CELL"],
                "value"   : None
            },
            "total_contributions": {
                "location": self.settings["TEMPLATE_TOTAL_CONTRIBUTIONS_CELL"],
                "value"   : None
            },
            "total_income" : {
                "location": self.settings["TEMPLATE_TOTAL_INCOME_CELL"],
                "value"   : None
            },
            "ytd_tier_1" : {
                "location": self.settings["TEMPLATE_YTD_TIER_1_CELL"],
                "value"   : None
            },
            "ytd_tier_2" : {
                "location": self.settings["TEMPLATE_YTD_TIER_2_CELL"],
                "value"   : None
            },
            "ytd_gross_pay" : {
                "location": self.settings["TEMPLATE_YTD_GROSS_PAY_CELL"],
                "value"   : None
            },
            "net_income"   : {
                "location": self.settings["TEMPLATE_NET_INCOME_CELL"],
                "value"   : None
            }
        }

    def load_employee_sheet(self):
        try:
            wb = load_workbook(self.employee_sheet_filepath)
            self.employee_sheet = wb[self.month]
            return self.employee_sheet
        except Exception as e:
            return -1

    def employee_sheet_rows_iter(self):
        header = True
        for row in self.employee_sheet:
            if header:
                header = False
            else:
                yield row

    def generate_payslip(self, employee_sheet_row):
        employee_entry = self.employee_sheet_headers.copy()

        for k, v in employee_entry.items():
            employee_entry[k] = employee_sheet_row[v.column_index].value if v.column else None

        assert type(employee_entry["staff_number"]) == int, f"For {self.month}, {employee_entry['name']} has no proper {self.settings['EMPLOYEE_STAFF_NUMBER_HEADER']} (it must be a number)"
        assert employee_entry["gross_income"] is not None, f"For {self.month}, {employee_entry['name']} has no {self.settings['EMPLOYEE_GROSS_INCOME_HEADER']} in the employee spreadsheet at least put 0 there"
        assert employee_entry["untaxed_bonus"] is not None, f"For {self.month}, {employee_entry['name']} has no {self.settings['EMPLOYEE_UNTAXED_BONUS_HEADER']} in the employee spreadsheet at least put 0 there"

        employee_entry.update(ghana_tax_calculator(int(employee_entry["gross_income"] *100), int(employee_entry["untaxed_bonus"] *100)).items())

        ytd_tracker = YTD_Tracker()
        ytd_tracker.set_month_record(self.month_no, employee_entry)
        employee_entry.update(ytd_tracker.get_cumulative_ytd(self.month_no, employee_entry))

        # Convert monetary fields from pesewas to GHS for export
        for k, v in employee_entry.items():
            if (k in list(ghana_tax_calculator(0,0).keys()) or "ytd" in k):
                v /= 100
                employee_entry[k] = f'{v:.2f}'

        payslip_details = self.template_sheet_cells.copy()

        for k,v in payslip_details.items():
            if "payslip" in k:
                continue

            if k == "account_number":
                v['value'] = f"ECOBANK: {employee_entry[k]}"
            else:
                v['value'] = employee_entry[k]

        payslip_xlsx_filepath = self.write_payslip_xlsx(payslip_details)
        assert payslip_xlsx_filepath, f"For {self.month}, {employee_entry['name']}, we  failed to create a payslip spreadsheet from the template"

        payslip_pdf_filepath = self.spreadsheet_to_pdf(payslip_xlsx_filepath)
        assert payslip_pdf_filepath, f"For {self.month}, {employee_entry['name']}, failed to convert payslip spreadsheet to pdf"

        return {
            "details"      : payslip_details,
            "xlsx_filepath": payslip_xlsx_filepath,
            "pdf_filepath" : payslip_pdf_filepath
        }

    def write_payslip_xlsx(self, payslip_details: dict):
        output_dir = Path(self.settings["EMPLOYEE_PAYSLIPS_FOLDER"]) / str(self.month)
        output_dir.mkdir(parents=True, exist_ok=True)
        output_path = output_dir / f"{payslip_details['name']['value'].replace(' ', '_')}_{self.month}_Payslip.xlsx"

        shutil.copy2(self.settings["PAYSLIP_TEMPLATE_FILEPATH"], output_path)

        wb = load_workbook(output_path)
        ws = wb.active

        # ✅ Capture & Re-add images (Openpyxl fails to keep them by default)
        images = list(ws._images)
        ws._images.clear()

        for img in images:
            ws.add_image(img)

        for v in payslip_details.values():
            if v['location']:
                ws[v['location']] = v.get('value')

        wb.save(output_path)
        wb.close()

        return str(output_path)

#    def write_payslip_xlsx(self, payslip_details: dict):
#        output_dir = Path(self.settings["EMPLOYEE_PAYSLIPS_FOLDER"]) / str(self.month)
#        output_dir.mkdir(parents=True, exist_ok=True)
#        output_path = output_dir / f"{payslip_details['name']['value'].replace(' ', '_')}_{self.month}_Payslip.xlsx"
#
#        # ✅ 1. Copy template (preserves ALL drawings/media perfectly)
#        shutil.copy2(self.settings["PAYSLIP_TEMPLATE_FILEPATH"], output_path)
#
#        import zipfile
#        import xml.etree.ElementTree as ET
#
#        # ✅ 2. Modify worksheet XML directly (bypass openpyxl save)
#        ns = {'main': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'}
#
#        with zipfile.ZipFile(output_path, 'r') as src:
#            # Read all files
#            files = {n: src.read(n) for n in src.namelist()}
#
#        # Modify sheet1.xml (cell values)
#        if 'xl/worksheets/sheet1.xml' in files:
#            sheet_xml = files['xl/worksheets/sheet1.xml']
#            root = ET.fromstring(sheet_xml)
#
#            # Build cell value map: {"B5": "1000", "B10": "200", ...}
#            cell_values = {}
#            for v in payslip_details.values():
#                if v['location'] and v.get('value') is not None:
#                    cell_values[v['location']] = str(v['value'])
#
#            # Find and update cells
#            for row in root.findall('.//main:row', ns):
#                for cell in row.findall('main:c', ns):
#                    cell_ref = cell.get('r')  # e.g., "B5"
#                    if cell_ref in cell_values:
#                        # Update or create value element
#                        v_elem = cell.find('main:v', ns)
#                        if v_elem is None:
#                            v_elem = ET.SubElement(cell, '{http://schemas.openxmlformats.org/spreadsheetml/2006/main}v')
#                        v_elem.text = cell_values[cell_ref]
#
#            # Write back
#            files['xl/worksheets/sheet1.xml'] = ET.tostring(root, encoding='UTF-8', xml_declaration=True)
#
#        # ✅ 3. Write everything back (drawings untouched)
#        with zipfile.ZipFile(output_path, 'w') as dst:
#            for name, data in files.items():
#                dst.writestr(name, data)
#
#        return str(output_path)

#    def write_payslip_xlsx(self, payslip_details: dict):
#        output_dir = Path(self.settings["EMPLOYEE_PAYSLIPS_FOLDER"]) / str(self.month)
#        output_dir.mkdir(parents=True, exist_ok=True)
#        output_path = output_dir / f"{payslip_details['name']['value'].replace(' ', '_')}_{self.month}_Payslip.xlsx"
#
#        # ✅ 1. Copy template (preserves drawings perfectly)
#        shutil.copy2(self.settings["PAYSLIP_TEMPLATE_FILEPATH"], output_path)
#
#        import zipfile
#        import xml.etree.ElementTree as ET
#
#        ns = {
#            'main': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
#            'xdr': 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
#            'a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
#            'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
#        }
#
#        # ✅ 2. Read all files from output
#        with zipfile.ZipFile(output_path, 'r') as src:
#            files = {n: src.read(n) for n in src.namelist()}
#
#        # ✅ 3. Modify worksheet XML (cell values only)
#        if 'xl/worksheets/sheet1.xml' in files:
#            sheet_root = ET.fromstring(files['xl/worksheets/sheet1.xml'])
#            
#            cell_values = {v['location']: str(v['value']) 
#                          for v in payslip_details.values() 
#                          if v.get('location') and v.get('value') is not None}
#            
#            for row in sheet_root.findall('.//main:row', ns):
#                for cell in row.findall('main:c', ns):
#                    if cell.get('r') in cell_values:
#                        v_elem = cell.find('main:v', ns)
#                        if v_elem is None:
#                            v_elem = ET.SubElement(cell, '{http://schemas.openxmlformats.org/spreadsheetml/2006/main}v')
#                        v_elem.text = cell_values[cell.get('r')]
#            
#            files['xl/worksheets/sheet1.xml'] = ET.tostring(sheet_root, encoding='UTF-8', xml_declaration=True)
#
#        # ✅ 4. Write back (drawings NEVER touched = size preserved)
#        with zipfile.ZipFile(output_path, 'w') as dst:
#            for name, data in files.items():
#                dst.writestr(name, data)
#
#        return str(output_path)

    def spreadsheet_to_pdf(self, spreadsheet_filepath):
        spreadsheet_path = Path(spreadsheet_filepath)
        pdf_path = spreadsheet_path.with_suffix('.pdf')

        for filepath in [spreadsheet_path, pdf_path]
            subprocess.run(['touch', filepath])
        subprocess.Popen(
            ["soffice", "--headless", "--convert-to", "pdf",
             "--outdir", str(spreadsheet_path.parent), str(spreadsheet_path)],
        )
#        subprocess.Popen(['pkill', '-9', '-f', 'soffice.bin.*--headless'])


        return str(pdf_path) if pdf_path.exists() else None

    def generate_payslips(self):
        subprocess.Popen(['pkill', '-9', '-f', 'soffice.bin.*--headless'])
        employee_spreadsheet_rows = list( self.employee_sheet_rows_iter() )

        assert employee_spreadsheet_rows, "For {self.month}, no employee payroll records exist"
        self.total += len(employee_spreadsheet_rows)

        for row in employee_spreadsheet_rows:
            payslip_info = self.generate_payslip(row)
            self.counter += 1

            if self.progress_callback:
                self.progress_callback(
                    counter=self.counter,
                    total=self.total,
                    name=payslip_info['details']['name']['value'],
                    email=payslip_info['details']['email']['value'],
                    month=self.month,
                    payslip_filepath=payslip_info['pdf_filepath']
                )
